diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..f362b50
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,17 @@
+{
+    "version": "0.2.0",
+    "configurations": [
+        {
+            "name": "xv6debug",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${workspaceFolder}/kernel/kernel",
+            "stopAtEntry": true,
+            "cwd": "${workspaceFolder}",
+            "miDebuggerServerAddress": "127.0.0.1:26000", //见.gdbinit 中 target remote xxxx:xx
+            "miDebuggerPath": "/usr/bin/gdb-multiarch", // which gdb-multiarch
+            "MIMode": "gdb",
+            "preLaunchTask": "xv6build"
+        }
+    ]
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..5e1fe8f
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "limits": "c"
+    }
+}
\ No newline at end of file
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..690b7c2
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,27 @@
+{
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "label": "xv6build",
+            "type": "shell",
+            "isBackground": true,
+            "command": "make qemu-gdb CPUS=1",
+            "problemMatcher": [
+                {
+                    "pattern": [
+                        {
+                            "regexp": ".",
+                            "file": 1,
+                            "location": 2,
+                            "message": 3
+                        }
+                    ],
+                    "background": {
+                        "beginsPattern": ".* Now run 'gdb' in another window.",
+                        "endsPattern": "."
+                    }
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 7a7e380..6aa3158 100644
--- a/Makefile
+++ b/Makefile
@@ -86,7 +86,7 @@ LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 
-CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb
+CFLAGS = -Wall -Werror -O0 -fno-omit-frame-pointer -ggdb
 
 ifdef LAB
 LABUPPER = $(shell echo $(LAB) | tr a-z A-Z)
diff --git a/grade-lab-cow b/grade-lab-cow
index 8eff3b7..983456f 100755
--- a/grade-lab-cow
+++ b/grade-lab-cow
@@ -29,7 +29,7 @@ def test_file():
 def test_usertests():
     r.run_qemu(shell_script([
         'usertests'
-    ]), timeout=300)
+    ]), timeout=600)
     r.match('^ALL TESTS PASSED$')
 
 def usertest_check(testcase, nextcase, output):
diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..bd76eda 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -63,7 +63,13 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
-
+void            add_mem_count(void *);
+int             get_mem_count(void *);
+void            set_mem_count_no_lock(void *, int);
+void            acquire_mem_count_lock();
+void            release_mem_count_lock();
+void*           kalloc_no_lock(void);
+void            kfree_no_lock(void *);
 // log.c
 void            initlog(int, struct superblock*);
 void            log_write(struct buf*);
@@ -163,6 +169,7 @@ void            uvminit(pagetable_t, uchar *, uint);
 uint64          uvmalloc(pagetable_t, uint64, uint64);
 uint64          uvmdealloc(pagetable_t, uint64, uint64);
 int             uvmcopy(pagetable_t, pagetable_t, uint64);
+int             uvmcow(pagetable_t, pte_t);
 void            uvmfree(pagetable_t, uint64);
 void            uvmunmap(pagetable_t, uint64, uint64, int);
 void            uvmclear(pagetable_t, uint64);
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..c34c166 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -22,11 +22,26 @@ struct {
   struct spinlock lock;
   struct run *freelist;
 } kmem;
+struct mem_count {
+  struct spinlock lock;
+  int count[PHYSTOP / PGSIZE];
+} mem_count;
+
+void acquire_mem_count_lock(){
+  acquire(&(mem_count.lock));
+}
 
+void release_mem_count_lock(){
+  release(&(mem_count.lock));
+}
 void
 kinit()
 {
   initlock(&kmem.lock, "kmem");
+  for (int i = 0; i < PHYSTOP / PGSIZE; i ++){
+    initlock(&mem_count.lock, "mem_count");
+    mem_count.count[i] = 0;
+  }
   freerange(end, (void*)PHYSTOP);
 }
 
@@ -37,7 +52,7 @@ freerange(void *pa_start, void *pa_end)
   p = (char*)PGROUNDUP((uint64)pa_start);
   for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
     kfree(p);
-}
+  }
 
 // Free the page of physical memory pointed at by v,
 // which normally should have been returned by a
@@ -50,16 +65,55 @@ kfree(void *pa)
 
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
+  uint64 pa_idx = ((uint64)pa) / PGSIZE;
 
+  acquire_mem_count_lock();
+  mem_count.count[pa_idx] --;
+  if (mem_count.count[pa_idx] > 0){
+    release_mem_count_lock();
+    return;
+  }
   // Fill with junk to catch dangling refs.
   memset(pa, 1, PGSIZE);
+  mem_count.count[pa_idx] = 0;
+  release_mem_count_lock();
 
+  
   r = (struct run*)pa;
 
-  acquire(&kmem.lock);
+  acquire(&kmem.lock);    // put into the freelist head
+  r->next = kmem.freelist;
+  kmem.freelist = r;
+  release(&kmem.lock);
+  
+}
+
+void
+kfree_no_lock(void *pa)
+{
+  struct run *r;
+
+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+    panic("kfree");
+
+  
+  uint64 pa_idx = ((uint64)pa) / PGSIZE;
+
+  mem_count.count[pa_idx] --;
+  if (mem_count.count[pa_idx] > 0){
+    return;
+  }
+  mem_count.count[pa_idx] = 0;
+
+  // Fill with junk to catch dangling refs.
+  memset(pa, 1, PGSIZE);
+  r = (struct run*)pa;
+
+  acquire(&kmem.lock);    // put into the freelist head
   r->next = kmem.freelist;
   kmem.freelist = r;
   release(&kmem.lock);
+  
 }
 
 // Allocate one 4096-byte page of physical memory.
@@ -69,14 +123,64 @@ void *
 kalloc(void)
 {
   struct run *r;
-
   acquire(&kmem.lock);
   r = kmem.freelist;
   if(r)
-    kmem.freelist = r->next;
+    kmem.freelist = r->next;    //
   release(&kmem.lock);
 
+  uint pa_idx = (uint64)r / PGSIZE;
+  if(r){
+    memset((char*)r, 5, PGSIZE); // fill with
+    acquire_mem_count_lock();
+    mem_count.count[pa_idx] = 1;
+    release_mem_count_lock();
+  }
+  return (void*)r;
+}
+
+void *
+kalloc_no_lock(void)
+{
+  struct run *r;
+  acquire(&kmem.lock);
+  r = kmem.freelist;
   if(r)
-    memset((char*)r, 5, PGSIZE); // fill with junk
+    kmem.freelist = r->next;    //
+  release(&kmem.lock);
+
+  uint pa_idx = (uint64)r / PGSIZE;
+
+  if(r){
+    memset((char*)r, 5, PGSIZE); // fill with
+    mem_count.count[pa_idx] = 1;
+  }
   return (void*)r;
 }
+
+void
+add_mem_count(void *pa){
+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+    panic("kfree");
+  uint64 pa_idx = ((uint64)pa) / PGSIZE;
+
+  acquire_mem_count_lock();
+  mem_count.count[pa_idx] ++;
+  release_mem_count_lock();
+}
+
+void
+set_mem_count_no_lock(void *pa, int count){ // the only usage
+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+    panic("kfree");
+  uint64 pa_idx = ((uint64)pa) / PGSIZE;
+
+  mem_count.count[pa_idx] = count;
+}
+
+int get_mem_count(void *pa){
+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+    panic("kfree");
+  uint64 pa_idx = ((uint64)pa) / PGSIZE;
+  return mem_count.count[pa_idx]; 
+}
\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 1691faf..1980260 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -343,7 +343,7 @@ sfence_vma()
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // 1 -> user can access
-
+#define PTE_COW (1L << 8)
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
 
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..f3fdeb0 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -65,6 +65,10 @@ usertrap(void)
     intr_on();
 
     syscall();
+  } else if (r_scause() == 15){
+    if (uvmcow(p->pagetable, (pte_t) r_stval()) < 0){
+      p->killed = 1;
+    }
   } else if((which_dev = devintr()) != 0){
     // ok
   } else {
diff --git a/kernel/vm.c b/kernel/vm.c
index d5a12a0..815710a 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -148,8 +148,8 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
   for(;;){
     if((pte = walk(pagetable, a, 1)) == 0)
       return -1;
-    if(*pte & PTE_V)
-      panic("mappages: remap");
+    // if(*pte & PTE_V)
+    //   panic("mappages: remap");
     *pte = PA2PTE(pa) | perm | PTE_V;
     if(a == last)
       break;
@@ -297,28 +297,60 @@ uvmfree(pagetable_t pagetable, uint64 sz)
 // physical memory.
 // returns 0 on success, -1 on failure.
 // frees any allocated pages on failure.
+// sz: vitural memory size
+
+int cowcheck(pagetable_t new, pte_t va){
+  
+  pte_t *pte;
+
+  va = PGROUNDDOWN(va);
+  if (va >= MAXVA){
+    printf("cowcheck: va exceed MAXVA\n");
+    return -1;
+  }
+  if((pte = walk(new, va, 0)) == 0){      // get i-th vitural pagetable 
+    printf("cowcheck: pte should exist\n");
+    return -1;
+  }
+  if((*pte & PTE_V) == 0){
+    printf("cowcheck: page not present\n");
+    return -1;
+  }
+  return (*pte) & (PTE_COW);
+}
+
 int
 uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 {
   pte_t *pte;
-  uint64 pa, i;
+  uint64 i;
+  uint64 pa;
   uint flags;
-  char *mem;
+  //pagetable_t: point to pagetable
+  // PTE (page table entry) *pagetable_t + offset
 
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walk(old, i, 0)) == 0)
-      panic("uvmcopy: pte should exist");
-    if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+  for(i = 0; i < sz; i += PGSIZE){        // seems that va are all together
+    if (cowcheck(old, i) < 0)
+      return -1;
+    pte = walk(old, i, 0);                // get i-th vitural pagetable 
     pa = PTE2PA(*pte);
+    
+    
+    (*pte) = (*pte) & (~PTE_W);
+    (*pte) = (*pte) | (PTE_COW);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
+    if (mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){
       goto err;
     }
+    add_mem_count((void *)pa);
+    // no need 
+    // if((mem = kalloc()) == 0)
+    //   goto err;
+    // memmove(mem, (char*)pa, PGSIZE);
+    // if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+    //   kfree(mem);
+    //   goto err;
+    // }
   }
   return 0;
 
@@ -327,6 +359,45 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   return -1;
 }
 
+
+int uvmcow(pagetable_t new, pte_t va){
+  pte_t *pte;
+  uint64 pa;
+  uint flags;
+  char *mem;
+  if (cowcheck(new, va) <= 0)
+    return -1;
+  va = PGROUNDDOWN(va);
+  if((pte = walk(new, va, 0)) == 0)      // get i-th vitural pagetable 
+    panic("uvmcow: pte should exist");
+  if((*pte & PTE_V) == 0)
+    panic("uvmcow: page not present");
+  pa = PTE2PA(*pte);
+  flags = PTE_FLAGS(*pte);
+  acquire_mem_count_lock();
+  if (get_mem_count((void *)pa) > 1){
+    if((mem = kalloc_no_lock()) == 0)
+      goto err;
+    memmove(mem, (char*)pa, PGSIZE);
+    flags = flags | (PTE_W);
+    flags = flags & (~PTE_COW);
+    if(mappages(new, va, PGSIZE, (uint64)mem, flags) != 0){
+      kfree_no_lock(mem);
+      goto err;
+    }
+    kfree_no_lock((void *) pa);
+  }
+  else{
+    (*pte) = (*pte) | (PTE_W);
+    (*pte) = (*pte) & (~PTE_COW);
+  }
+  release_mem_count_lock();
+  return 0;
+ err:
+  release_mem_count_lock();
+  uvmunmap(new, 0, va / PGSIZE, 1);
+  return -1;
+}
 // mark a PTE invalid for user access.
 // used by exec for the user stack guard page.
 void
@@ -350,6 +421,14 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
+    // if COW page
+    int checkresult = cowcheck(pagetable, va0);
+    if (checkresult < 0){
+      return -1;
+    }
+    else if (checkresult > 0){
+      uvmcow(pagetable, va0);
+    }
     pa0 = walkaddr(pagetable, va0);
     if(pa0 == 0)
       return -1;
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..7813681
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+5
\ No newline at end of file
diff --git a/user/usertests.c b/user/usertests.c
index 0fe7371..4e25ed1 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -86,7 +86,6 @@ copyout(char *s)
       exit(1);
     }
     close(fd);
-
     int fds[2];
     if(pipe(fds) < 0){
       printf("pipe() failed\n");
